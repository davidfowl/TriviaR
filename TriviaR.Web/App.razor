@inject NavigationManager NavigationManager

<h1>TriviaR@(gameName is not null ? $" - {gameName}" : "")</h1>

@if (currentQuestion is not null)
{
    <div id="question">
        <span style="padding:5px">@currentQuestion.Question</span>

        <ol>
        @for (int i = 0; i < currentQuestion.Choices.Length; i++)
        {
            var choiceIndex = i;
            var choice = currentQuestion.Choices[i];
            <li style="padding:5px;">
                <button disabled="@currentAnswer" @onclick="(() => AnswerQuestion(choiceIndex))">@choice</button>
            </li>
        }
        </ol>
    </div>
}

<ul>
    @foreach (var message in messages)
    {
        <li>@message</li>
    }
</ul>

@code
{
    List<string> messages = new();

    string? gameName;

    // The current question
    GameQuestion? currentQuestion;

    bool currentAnswer;

    // Treat the channel like a reusable TaskCompletionSource
    Channel<GameAnswer> answers = Channel.CreateUnbounded<GameAnswer>();

    TimeSpan timeoutPerQuestion;
    int totalQuestions;

    protected override async Task OnInitializedAsync()
    {
        var connection = new HubConnectionBuilder()
                        .WithUrl(NavigationManager.ToAbsoluteUri("/trivia"))
                        .Build();

        // Wire up the event callbacks
        connection.On<string>(nameof(WriteMessage), WriteMessage);
        connection.On<GameQuestion, GameAnswer>(nameof(AskQuestion), AskQuestion);
        connection.On<GameConfiguration>(nameof(GameStarted), GameStarted);
        connection.On<string, int>(nameof(GameCompleted), GameCompleted);

        connection.Closed += (ex) =>
        {
            WriteMessage("Connection closed.");

            return Task.CompletedTask;
        };

        await connection.StartAsync();
    }

    void AnswerQuestion(int choice)
    {
        if (!currentAnswer)
        {
            currentAnswer = true;

            // Respond to the currently pending client result (AskQuestion)
            answers.Writer.TryWrite(new GameAnswer { Choice = choice });
        }
    }

    void WriteMessage(string message)
    {
        messages.Add(message);

        InvokeAsync(StateHasChanged);
    }

    void GameStarted(GameConfiguration gameConfiguration)
    {
        gameName = gameConfiguration.Name;
        totalQuestions = gameConfiguration.NumberOfQuestions;
        timeoutPerQuestion = TimeSpan.FromSeconds(gameConfiguration.QuestionTimeout);

        messages.Clear();
        WriteMessage($"Game {gameConfiguration.Name} has started. Prepare to answer {gameConfiguration.NumberOfQuestions} trivia questions!");
    }

    void GameCompleted(string game, int correct)
    {
        currentAnswer = false;
        currentQuestion = null;

        messages.Clear();
        WriteMessage($"Game {game} is completed. Your score is {correct}/{totalQuestions}");
    }

    async Task<GameAnswer> AskQuestion(GameQuestion question)
    {
        currentAnswer = false;

        messages.Clear();

        currentQuestion = question;

        await InvokeAsync(StateHasChanged);

        using var cts = new CancellationTokenSource(timeoutPerQuestion);

        try
        {
            // Wait for the answer to be written to the channel
            return await answers.Reader.ReadAsync(cts.Token);
        }
        catch (OperationCanceledException)
        {
            // We timed out waiting for an answer
            currentAnswer = true;

            WriteMessage("Times up!");

            throw;
        }
    }
}